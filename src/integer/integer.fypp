#:include "../common.fypp"
!| The `numeric_integer` module provides constants and procedures related to integer.
!
! The constants include minimum and maximum values of the integer types provided by the Fortran standard
! and parameters for specifying the result kind of the intrinsic procedures like `transfer`.
!
! The procedures include functions to get the number of digits of an integer variable,
! check whether an integer is positive/negative, and convert an integer to a string in a specified format.
!
module numeric_integer
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: get_digit
    public :: to_string
    public :: is_positive
    public :: is_negative

    #:for int_kind in INTEGER_KINDS
        integer(${int_kind}$), public, parameter :: result_type_${int_kind}$ = 0_${int_kind}$
    #:endfor

    integer(int8), public, parameter :: Int8_Max = int(Z'7F', int8)
        !! The maximum value of 1-byte signed integer `=+127`
    integer(int8), public, parameter :: Int8_Min = int(-Int8_Max-1, int8) !&
        !! The minimum value of 1-byte signed integer `=-128`

    integer(int16), public, parameter :: Int16_Max = int(Z'7FFF', int16)
        !! The maximum value of 2-byte signed integer `=+32,767`
    integer(int16), public, parameter :: Int16_Min = int(-Int16_Max-1, int16) !&
        !! The minimum value of 2-byte signed integer `=-32,768`

    integer(int32), public, parameter :: Int32_Max = int(Z'7FFFFFFF', int32)
        !! The maximum value of 4-byte signed integer `=+2,147,483,647`
    integer(int32), public, parameter :: Int32_Min = int(-Int32_Max-1, int32) !&
        !! The minimum value of 4-byte signed integer `=-2,147,483,648`

    integer(int64), public, parameter :: Int64_Max = int(Z'7FFFFFFFFFFFFFFF', int64)
        !! The maximum value of 8-byte signed integer `=+9,223,372,036,854,775,807`
    integer(int64), public, parameter :: Int64_Min = int(-Int64_Max-1, int64) !&
        !! The minimum value of 8-byte signed integer `=-9,223,372,036,854,775,808`

    !| Returns a number of digits of an integer.
    interface get_digit
        #:for int_kind in INTEGER_KINDS
            procedure :: get_digit_${int_kind}$
        #:endfor
    end interface

    !| Returns a string created by converting an integer.
    interface to_string
        #:for int_kind in INTEGER_KINDS
            procedure :: ${int_kind}$_to_string_with_format
            procedure :: ${int_kind}$_to_string_with_digits
        #:endfor

    end interface

    !| Returns `.true.` if an integer is positive, including 0.
    interface is_positive
        #:for int_kind in INTEGER_KINDS
            procedure :: is_positive_${int_kind}$
        #:endfor
    end interface

    !| Returns `.true.` if an integer is negative, not including 0.
    interface is_negative
        #:for int_kind in INTEGER_KINDS
            procedure :: is_negative_${int_kind}$
        #:endfor
    end interface

    character(*), private, parameter :: default_integer_format = '(i0.0)'

    integer(int32), private, parameter :: MaxLength_of_IOMessage = 255
    integer(int32), private, parameter :: MaxLength_of_Buffer = 255

contains
    !| Gets the number of digits of 1-byte integer.
    #:for int_kind in INTEGER_KINDS
        pure function get_digit_${int_kind}$ (val) result(digits)
            implicit none
            !&<
            integer(${int_kind}$), intent(in)    :: val
                !! integer value
            !&>
            integer(int32) :: digits
                !! A number of digits in `val` value

            integer(${int_kind}$) :: i

            i = abs(val)
            digits = 1

            do while (i >= 10_${int_kind}$)
                i = i/10_${int_kind}$
                digits = digits + 1
            end do
        end function get_digit_${int_kind}$
    #:endfor

    !------------------------------------------------------------------!
    !| Converts an integer to a string based on a format passed as an argument.
    ! When the format is not given, `'(i0.0)'` is used as the format.
    ! A zero-length string is returned when the convert is failed.
    #:for int_kind in INTEGER_KINDS
        function ${int_kind}$_to_string_with_format(val, format) result(str)
            implicit none
            !&<
            integer(${int_kind}$)  , intent(in)            :: val
                !! integer value
            character(*)    , intent(in), optional  :: format
                !! format for string conversion
            !&>
            character(:), allocatable :: str
                !! a converted string

            character(MaxLength_of_Buffer) :: buffer
            integer :: IOStatus
            character(MaxLength_of_IOMessage) :: IOMessage

            ! The validation of the format is not checked.
            if (present(format)) then
                write (buffer, format, iostat=IOStatus, iomsg=IOMessage) val
            else
                write (buffer, default_integer_format, iostat=IOStatus, iomsg=IOMessage) val
            end if

            ! The convert is failed
            if (IOStatus /= 0) then
                write (error_unit, '(A)') trim(IOMessage)
                buffer = "" ! returns a zero-length string
            end if

            str = trim(buffer)
        end function ${int_kind}$_to_string_with_format
    #:endfor

    !|A function converts an integer to a string based on the number of digits and zero-filling digits passed as arguments.
    ! When the format is not given, `'(i0.0)'` is used as the format.
    ! A zero-length string is returned when the convert is failed.
    #:for int_kind in INTEGER_KINDS
        function ${int_kind}$_to_string_with_digits(val, digit, zerofill) result(str)
            implicit none
            !&<
            integer(${int_kind}$), intent(in)              :: val
                !! integer value
            integer(int32), intent(in)              :: digit
                !! The number of digits in the converted string
            integer(int32), intent(in), optional    :: zerofill
                !! The number of digits to fill with zeros
            !&>
            character(:), allocatable :: str
                !! a converted string

            integer(int32), parameter :: Extra_Digits_Sign = 1

            character(:), allocatable :: fmt
            character(:), allocatable :: str_digits
            character(:), allocatable :: str_zfill

            ! construct format string
            if (is_positive(val)) then
                str_digits = int32_to_string_with_format(digit)
            else
                str_digits = int32_to_string_with_format(digit + Extra_Digits_Sign) ! add 1 to digit for minus sign
            end if

            if (present(zerofill)) then
                if (zerofill > digit) then
                    str_zfill = int32_to_string_with_format(digit)
                    ! format such as '(i10.11)' is not allowed. zero-filling digits are limited to `digit`
                else
                    str_zfill = int32_to_string_with_format(zerofill)
                end if
                str_zfill = "."//str_zfill
            else
                str_zfill = ""
            end if

            fmt = "(I"//str_digits//str_zfill//")"

            str = to_string(val, fmt)
        end function ${int_kind}$_to_string_with_digits
    #:endfor

    !------------------------------------------------------------------!
    #:for int_kind in INTEGER_KINDS
        !| Returns `.true.` if the integer(${int_kind}$) is positive, including 0.
        pure logical function is_positive_${int_kind}$ (val)
            implicit none
            !&<
            integer(${int_kind}$), intent(in)    :: val
                !! integer value
            !&>

            if (val >= 0) then
                is_positive_${int_kind}$ = .true.
            else
                is_positive_${int_kind}$ = .false.
            end if
        end function is_positive_${int_kind}$
    #:endfor

    !------------------------------------------------------------------!
    #:for int_kind in INTEGER_KINDS
        !| Returns `.true.` if the integer(${int_kind}$) is negative, not including 0.
        pure logical function is_negative_${int_kind}$ (val)
            implicit none
            !&<
            integer(${int_kind}$), intent(in)    :: val
                !! integer value
            !&>

            is_negative_${int_kind}$ = .not. is_positive(val)
        end function is_negative_${int_kind}$
    #:endfor
end module numeric_integer
